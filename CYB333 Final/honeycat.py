#!/usr/bin/python3

#modules
import os #module used for creating and reading files and directories.
import http.server #module used for creating the http server.
import socketserver #module with http.server to manage the http server.
import sys #module used for reading and redirecting system output and errors.
import shutil #module used to delete directories from the python script.
import functools #used to modify the server handler to allow arbitrary pwd.


#Branding Banner
#Cat ASCII comic adopted from H.J. Wakenshaw,2025 (https://www.asciiart.eu/animals/cats)
#Stylized titled ASCII comic generated by https://patorjk.com/
print(r"""
        _..---...,""-._     ,/}/)
     .''        ,      ``..'(/-<
    /   _      {      )         \
   ;   _ `.     `.   <         a(
 ,'   ( \  )      `.  \ __.._ .: y
(  <\_-) )'-.____...\  `._   //-'
 `. `-' /-._)))      `-._)))
   `...')
""")
print("Curiosity killed the cat...")
print(r"""

    __  __                       ______      __ 
   / / / /___  ____  ___  __  __/ ____/___ _/ /_
  / /_/ / __ \/ __ \/ _ \/ / / / /   / __ `/ __/
 / __  / /_/ / / / /  __/ /_/ / /___/ /_/ / /_  
/_/ /_/\____/_/ /_/\___/\__, /\____/\__,_/\__/  
                       /____/                   
""")

print("Written by Cewl10 for CYB333 at National University.\n")


#variable created to hold the http server, and functools is used to direct the server to an
#arbitrary directory.
handler = functools.partial(http.server.SimpleHTTPRequestHandler, directory='./home')

#Logging class created to allow simultaneous streaming/logging of stdout/stderr
class honeylog(object):
	def __init__(self): #function defined to initilaize the logfile as a repository for the stderr
		self.terminal = sys.stderr
		self.log = open('logfile', 'a')
	def write(self, message): #function defined to allow the stderr to also display onscreen
		self.terminal.write(message)
		self.log.write(message)
sys.stderr = honeylog() #sys.stderr = honeylog() #ultimate redirect of standard error to the log class.

#Below: try and except clauses used for exception handling, input validation, and for graceful exit.
try:
	port = int(input("\nPress CTRL+C to exit, or enter desired port number: ")) #user prompted for input to assign port number.
except	KeyboardInterrupt: #Except clause used for graceful exit that detect ctrl+c, closes the server, and quits the program.
	sys.stderr.log.close()
	print("\nError Code 1 - Fine. HoneyCat doesn't like you anyway...\n")
	quit()
except: #Exception handling for all other exception. Code numbering was added to assist with debugging.
#All exceptions besides keyboard interrupt result in the message, close of the files, and removing of
#the blacklist script and the logfile, then graceful exit of the program.
	print('\nError Code 2 - Syntax error - port number must contain numbers only. Restart HoneyCat and try again.\n')
	logF.close()
	black.close()
	os.remove('./blacklist.sh')
	os.remove('./logfile')
	quit()



def main(): #Start of the main functionality in the script.
	list = ['home/billy/Pictures/DatingAppSelfies/', 'home/billy/Downloads/BankingInfo/', 'home/billy/CryptoWallet/'] #list from which directories are populated.
#above: list created of honeypot directories.
#below: a loop iterates through the list above.
	for i in list: #loop to generate directories with 655 permissions.
		os.makedirs(i, mode=0o655)
#Below: rootDir is the point of reference for os.walk, which creates folders/files.
#A for loop is created to iterate through files and folder, starting at rootDir,
#and the existig files/folders are enumerated in a separate for loop.
	print('\n\nHoneypot created. Checking directory listing...\n\n')
	try:
		rootDir = 'home'
		for dirName, subDirList, fileList, in os.walk(rootDir):
			print('Found directory: %s' % dirName)
		for n in fileList:
			print('\t%s' % n)
#Below: exception handling for honeypot directory creation. The try/except clause inside of the 
#exception was created to deal with the shutil module crashing the program if I re-ran it and 
#forgot to delete the honeypot. Exception handling removes the script and log, closes the http server,
#and prints and error message. Error code added to assist with debugging.
	except:
		try:
			shutil.rmtree('home')
		except:
			pass
		httpd.server_close()
		os.remove('./blacklist.sh')
		os.remove('./logfile')
		print("\nError Code 3 - An error has occured. Restart HoneyCat and try again.\n")
#Below: Socketserver and http.server are used to open the simple HTTP server.
#Exception handling is used for a) the Keyboard Interrupt command used to close the server, and
#b) to provide for graceful shutdown in the case errors are encountered. The while loop is used to 
#ensure that the server only stays open until keyboard interrupt, at which point it is closed, the
#log is closed, and the honeypot directory tree is deleted.
	while True:
		logF = open('logfile', 'a')
		try:
			with socketserver.TCPServer(('127.0.0.1', port), handler) as httpd:
				httpd.allow_reuse_address = True #handling for the error 98 address already in use problem when re-running on the same port.
				print(f"\n\nHoneypot looks good.\n\nHoneycat is purring on port {port}...\nPress CTR+C to stop the server and generate logs.\n")
				httpd.serve_forever()
		except:
			break
		if KeyboardInterrupt:
			print("\n\n-----\nmeow\n-----\n\n")
			httpd.server_close()
			logF.close()
			try:
				shutil.rmtree('home') #Closes the server and deletes the honeypot.
			except:
				continue
	sys.stderr.log.close() #this closes the honeylog where the server output was redirected to.
# Below: An empty list is created to hold the contents of the logfile entry per line. The log file is
# opened and assigned a new handle (logG). The first loop iterates through the log and grabs each entry
# to append to the list, then closes the log file. Then, in the blacklist script, HoneyCat makes a "shebang" header, then iterates
# through the ipAdd list in string IP string fashion to write the ufw rules to the file. At the
# conclusion of the loop, the bash script file is closed.
	try:
		ipAdd = []
		logG = open('logfile', 'r')
		black = open('blacklist.sh', 'a')
		with logG as file:
			for i in file:
				ipAdd.append(i)
			logG.close()
		with black as b:
			b.write('#!/bin/bash\n')
			for item in ipAdd:
				b.write('sudo ufw deny from ' + item.split('-')[0] + 'to any\n')
			b.close()
	except:
		pass

# Below: the finally clause is used to inform the user that the program is done and what to do with
# the bash script, then attempts one more time to close the log file and the bash script and
# to delete the honeypot directory tree and the log file (just in case).

	finally:
		print("\n\nComplete. Run 'sudo blacklist.sh' in the terminal to block the IPs.\n\nHave a nice day!\n")
		logG.close()
		black.close()
		try:
			shutil.rmtree('home')
			os.remove('./logfile')
		except:
			pass
		quit()


if __name__ == '__main__': #python best practice to ensure main function is properly assigned in memory
	main()
